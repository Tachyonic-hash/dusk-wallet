package transactions

import (
	"bytes"
	"dusk-wallet/key"
	"dusk-wallet/mlsag"
	"errors"

	dtx "dusk-wallet/transactions/dusk-go-tx"

	"github.com/bwesterb/go-ristretto"
)

type Input struct {
	//baseInput is the input type used in dusk-go the serialisable format.
	// XXX: possibly change variable name
	baseInput dtx.Input
	// Commitment to the amount and the mask value
	// This will be generated by the rangeproof
	Commitment   ristretto.Point
	amount, mask ristretto.Scalar
	// One-time pubkey of the receiver
	// Each input will contain a one-time pubkey
	// Only the private key assosciated with this
	// public key can unlock the funds available at this utxo
	PubKey  key.StealthAddress
	privKey ristretto.Scalar
	//PseudoCommitment refers to a commitment which commits to the same amount
	// as our `Commitment` value, however the mask value is changed. This is to be used in proving
	// that the sumInputs-SumOutputs = 0
	PseudoCommitment ristretto.Point
	// Proof is zk proof that proves that the signer knows the one-time pubkey assosciated with
	// an input in the ring. The secondary key in the key-vector is used as an intermediate process
	// for the balance proof. This will use a pseudo-commitment s.t. C = Comm(amount, r)
	// However, in order for the proof to work we need to know all inputs and outputs in the tx.
	// Proof will output a signature and a keyimage
	Proof *mlsag.DualKey
}

/// XXX: maybe we should take an dusk-tx-output and the privkey
// We can then derive the amount, mask from the encrypted amounts
// We can derive the mask from encryptedMask, as it is deterministic
// we can also derive the pubkey
func NewInput(amount, mask, privkey ristretto.Scalar) *Input {

	commitment := CommitAmount(amount, mask)

	i := &Input{
		Commitment: commitment,
		amount:     amount,
		mask:       mask,
		privKey:    privkey,
		Proof:      mlsag.NewDualKey(),
	}

	// Set the primary key in the mlsag proof; the key needed to unlock this input
	pubkey := i.Proof.SetPrimaryKey(privkey)

	// Save the pubkey assosciated with the primary key
	// XXX: does the input layer use this anymore? or is it just the mlsag layer
	i.PubKey = key.StealthAddress{P: pubkey}

	return i
}

func (i *Input) setPseudoComm(x ristretto.Point) {
	i.PseudoCommitment = x
	i.baseInput.PseudoCommitment = x.Bytes()
}

func (i *Input) Prove() (*mlsag.Signature, *ristretto.Point, error) {
	sig, keyImage, err := i.Proof.Prove()
	if err != nil {
		return nil, nil, err
	}

	// Set the keyimage in the serialisable format
	i.baseInput.KeyImage = keyImage.Bytes()

	// Set the signature in the baseinput
	buf := &bytes.Buffer{}
	err = sig.Encode(buf, false)
	if err != nil {
		return nil, nil, err
	}
	i.baseInput.Signature = buf.Bytes()

	return sig, &keyImage, err
}

// Encode will convert this input type to a dusk-go input
// The dusk-go input requires the index of this in
func (i *Input) Encode() dtx.Input {
	return i.baseInput
}

func (i *Input) AddDecoy(globalOffset []byte, pubKeys mlsag.PubKeys) {

	// Add offset to baseInput
	i.baseInput.AddInput(globalOffset)

	// Add pubkeys to MLSAG proof
	i.Proof.AddDecoy(pubKeys)
}

func (i *Input) AddDecoys(globalOffsets [][]byte, pubKeysMatrix []mlsag.PubKeys) error {
	if len(globalOffsets) != len(pubKeysMatrix) {
		return errors.New("there needs to be an offset for each decoy's key vector")
	}

	for k := range globalOffsets {
		offset := globalOffsets[k]
		pubKeys := pubKeysMatrix[k]
		i.AddDecoy(offset, pubKeys)
	}

	return nil
}
